*스칼라의 기본 문법
스칼라를 사용함에 있어서 상호원활한 의사소통을 위해 지켜야 하는 문법이다
-대소문자를 구분한다. : 스칼라에서는 대소문자를 구분하기 때문에 hello와 Hello는 다르다
-클래스이름 첫글자는 대문자 : 스칼라의 모든 클래스의 첫번째 문자는 대문자로 시작하여야 한다. 만약 여러개의 단어로 되어있다면 각 단어마다 첫글자는 대문자로 한다.
   ex : class MyFirstScalaClass
-메소드이름 첫글자는 소문자 : 스칼라의 모든 메소드는 소문자로 시작하여야 한다. 만약 여러개의 단어로 되어있다면 첫 단어는 소문자, 다음 단어는 대문자로 한다.
   ex : def myMethodName()
-프로그램 파일 이름은 오브젝트 이름과 정확하게 매치되어야 한다.(저장 할 때 스칼라는 대소문자를 구분한다는것을 기억해야한다)그리고 .scala라는 확장자가 붙어야 한다.
   ex : HelloWorld -> HellWorld.scala
-스칼라는 항상 다음과 같은 메소드를 필수적으로 가지고 있어야 한다. def main(args : Array[String])
-스칼라의 변수는 항상 문자 또는 언더스코어로 시작하여야 한다. $aaa,123abc, -bbc 는 가급적 사용하지 않는것이 좋다.($는 특히 언어 예약어이기 때문에)
-연산자 식별자는 +, :, ?, ~ , #등이 있다. $는 scala컴파일러가 코드를 컴파일시 네임맹글링(컴파일시 개발자가 작성한 변수, 함수 등에 동일한 명칭을 구분하기 위해 컴파일러 자체적으로 변경시키는것)시 사용하기 때문에 사용을 자제하는것이 좋다
-주석은 // 와 /* */를 사용한다.
-스칼라는 라인지향 언어 이기 때문에 세미콜론은 옵션이다. 즉 한가지 문법만 사용한다면 세미콜론없이 newline을 하면 된다. 만약 한줄에 여러 문법을 작성한다면 세미콜론이 필요하다

*스칼라에서 사용하는 데이터타입
일반적으로 자바에서 사용하는 데이터타입을 제외함
Unit = 대응되는 변수가 없을때 사용하는 타입
Any = 최상위클래스로 모든 타입을 다 받을 수 있다.
AnyRef = 레퍼런스의 최상위 타입으로 레퍼런스와 관련된 모든 타입을 받을 수 있다.
Nothing = 모든타입의 최하위 타입으로 정해진 타입외에 exception을 리턴하게 되면 컴파일러가 Nothing으로 추론을함
Null = null 또는 empty reference

*Mult-Line String
스칼라에서 문자열을 나타내는데 한줄 이상을 사용한다면 """를 붙여야 한다.

*변수 선언시 var과 val의 차이점
var은 mutable variable(변경이 가능한 변수), val는 immutable variable(변경이 불가능한 변수)를 뜻한다.

*변수 타입 추론
스칼라에서는 java와 달리 타입을 자동으로 추론해주는 기능이 있다.  var myVar = 10; 은 컴파일 시 정수형 타입이라는 추론을 해준다.

*다중 할당
스칼라에서는 코드블록 또는 튜플(다른 타입객체들을 하나로 모아놓은것)를 이용하여 다중할당이라는 기능을 지원해 준다.

*변수의 범위
필드 : 변수 오브젝트 내부에 선언한 부분으로 오브젝트 내부의 메소드 또는 외부에서 접근이 가능하다.
메소드 매개변수 : 변수의 mutable, immutable선언을 하지 않는다면 매개변수는 메소드 안에서만 사용이 가능하지만 var, val를 명시한다면 외부에서도 사용이 가능하다.
지역변수 : 지역변수는 메소드 내부에 선언된 변수로 필드와 같은 기능을 한다.

*스칼라 함수
def function (x : Int, y : Int) : Int={
}
에서 :Int가 함수의 리턴값
데이터타입은 대문자로 시작
: 는 할당해주는거 같음 

Unit는 void와 같음


*List에서 유의사항
List[Int] 정수형 리스트가 있다
var element : List[Int] 일때
  element = x :: element 의 뜻은 List맨 앞부분에 x라는 값을 추가하라는 뜻
  element = (x, element) 이런 느낌임
  element.head는 맨 앞부분 원소 하나를 뜻한다.
  element.tail은 맨 앞부분 원소를 제외한 나머지를 뜻한다

  위상황에서 
  element.head는 x를 element.tail은 x를 제외한 나머지 element리스트의 원소들을 나타낸다.


*스칼라의 데이터타입 계층구조
 스칼라의 모든 값들은 객체(Object)이다 심지어 숫자와 함수까지도 객체로 취급한다.
 모든 객체의 최상위 클래스는 scala.Any이다. 이것을 scala.AnyVal과 scala.AnyRef로 나눠진다.
 또 scala.AnyVal은 scala.Double, Float, Long, Int ... 등등을 하위 클래스로 가지고 있다(이렇게 객체의 첫글자가 대문자이기때문에 데이터타입을 할달 할 때 대문자인가보다)
 그리고 scala.AnyRef는 Java.lang.String 같은 자바 클래스들과 스칼라 객체들을 하위 클래스로 가지고 있다
 또한 scala.Null과 scala.Nothing가 있다.

*스칼라 클래스
스칼라의 클래스는 정적 탬플릿이다 그리고 런타임때 인스턴스화 된다.(이건 다른 객체지향도 마찬가지)
!!!!스칼라의 클래스이름의 첫번째 문자는 대문자로 쓰는것이 기본 스칼라 문법이다!!!!
class Point(xc : Int, yc : Int) {
	var x : Int = xc
        var y : Int = yc
        def move(dx : Int, dy : Int) {
        	x = x + dx
                y = y + dy
	}
	override def toString() : String = "(" + x + ", "+ y + ")"
}
위의 클래스는 매개변수로 x,y 값을 받아 move함수로 좌표를 변경하고 출력을 하는 클래스이다.
우선 접근지정자에 대해서 보자면 클래스 내부에 명시를 하지않는다면 무조건 public지정이다(public를 명시하면 오히려 에러가 난다)
나머지 접근지정자인 private, protected는 명시를 해주어야 작동이 된다.

그리고 눈에 띄는것은 클래스에 매개변수가 있다는 것이다. Java나 c++, c#에서는 클래스 내부에서 생성자를 통해 오버로딩 하지만 스칼라는 클래스 옆에 명시를 한다.
만약 생성자를 오버라이딩을 하려면 최상위 클래스를 추상 클래스로 만들고 상속을 받아 사용해야 할 것 같다. (자식클래스들의 이름은 서로 달라야한다.)

위의 클래스는 객체생성시 xc와 yc라는 매개변수를 넣어주어야 한다. 그리고 매개변수를 선언 할 떄도 
(val xc:Int, val yc:Int) 같은 형식과
(var xc:Int, var yc:Int)와 같은 형식도 존재한다. val과 var은 클래스 외부에서 참조가 가능한 매개변수이다. 만약 var, val을 쓰지 않았다면 클래스 내부에서만 사용이 된다.

var x : Int = xc 는 클래스 멤버변수로서 Int형 변수 x에 매개변수 xc의 값을 할당 해주고있다.
def move(dx : Int, dy : Int) 는 클래스 내부에 맴버함수이면서 정수형 변수 dx, dy를 할당 받아 x,y에 증가시켜준다.
스칼라에는 증감연산자가 없다.(x++, x--, ++x 등 모두 에러로 처리된다)

override def toString() : String 는 자바와 같이 toString을 오버라이드 하여 사용하고 있다. 오버라이드시에는 override라고 명시를 해주어야 한다.
:String은 문자열을 리턴한다는 뜻이다.

*Singleton Object(싱글턴 오브젝트)

*스칼라에서 오버로딩이 없는 이유
스칼라에서는 _라는 기능이 있다. 예로들어 import java.io._ (자바 import java.io.*와 같은 뜻이다.) 이외에도 임의의 한 객체를 나타내기 때문에
만약 def a(b : Int), def a(c : Boolean) 라는 오버로딩이 있다면 스칼라는 이것을 해석 하지 못한다.



알아야 할것 
implicit
<: 
A =:= B	A는 B와 같아야 함
A <:< B	A는 B의 하위 타입이어야 함
A <%< B	A는 B로 볼 수 있어야 함